---
# Launch nDisplay cluster via command line (no Switchboard)
# Starts UnrealEditor on each content node in nDisplay mode.
#
# Reference command (from Epic Forums):
#   https://forums.unrealengine.com/t/how-to-run-ndisplay-by-script-or-command-line/479685
#
#   UnrealEditor.exe "Project.uproject" -game None -messaging -dc_cluster -nosplash
#     -dc_cfg="path/to/config.ndisplay" -dc_node=Node_0 -dc_dev_mono
#     -ini:Engine:[/Script/Engine.Engine]:GameEngine=/Script/DisplayCluster.DisplayClusterGameEngine,[/Script/Engine.Engine]:GameViewportClientClassName=/Script/DisplayCluster.DisplayClusterViewportClient
#     -ini:Game:[/Script/EngineSettings.GeneralProjectSettings]:bUseBorderlessWindow=True
#     -ini:Input:[/Script/Engine.InputSettings]:DefaultPlayerInputClass=/Script/DisplayCluster.DisplayClusterPlayerInput
#     -unattended -NoScreenMessages -fixedseed -NoVerifyGC -noxrstereo
#     -RemoteControlIsHeadless -StageFriendlyName="Node_0" Log=Node_0.log
#
# Prerequisites:
#   - Populate ndisplay_map and ndisplay_config in
#     inventories/hrlv-dev/group_vars/ue_content.yml
#   - Plastic SCM synced (playbooks/plastic-sync.yml)
#   - Firewall rules applied (playbooks/ue-firewall-rules.yml)
#
# Usage:
#   ansible-playbook playbooks/ue-ndisplay-start.yml
#   ansible-playbook playbooks/ue-ndisplay-start.yml -e "ndisplay_map=/Game/Path/To/Map"

- name: GPU health check
  ansible.builtin.import_playbook: gpu-health-check.yml

- name: Prime OVS FDB for Rivermax hardware offload
  ansible.builtin.import_playbook: rivermax-arp-prime.yml

- name: Rivermax preflight check
  hosts: ue_content
  gather_facts: false

  tasks:
    - name: Skip preflight if not using Rivermax config
      ansible.builtin.meta: end_host
      when: not (ndisplay | default('') is match('rivermax.*'))

    - name: Check Rivermax DLL exists
      ansible.windows.win_stat:
        path: 'C:\Program Files\Mellanox\Rivermax\lib\rivermax.dll'
      register: preflight_dll

    - name: Check Rivermax license exists
      ansible.windows.win_stat:
        path: 'C:\Program Files\Mellanox\Rivermax\lib\rivermax.lic'
      register: preflight_lic

    - name: Check RIVERMAX_LICENSE_PATH is set
      ansible.windows.win_shell: |
        [System.Environment]::GetEnvironmentVariable('RIVERMAX_LICENSE_PATH', 'Machine')
      register: preflight_env
      changed_when: false

    - name: Check Mellanox adapter visible
      ansible.windows.win_shell: |
        $adapter = Get-NetAdapter | Where-Object {
          $_.InterfaceDescription -like '*Mellanox*' -or $_.InterfaceDescription -like '*ConnectX*'
        }
        if ($adapter) { Write-Host "OK: $($adapter.Name) ($($adapter.InterfaceDescription)) - $($adapter.Status)" }
        else { Write-Host "MISSING" }
      register: preflight_adapter
      changed_when: false

    - name: Fail if Rivermax is not ready
      ansible.builtin.fail:
        msg: |-
          Rivermax preflight FAILED on {{ inventory_hostname }}:
          {% if not preflight_dll.stat.exists %}  - Rivermax DLL missing (C:\Program Files\Mellanox\Rivermax\lib\rivermax.dll)
          {% endif %}{% if not preflight_lic.stat.exists %}  - License file missing (C:\Program Files\Mellanox\Rivermax\lib\rivermax.lic)
          {% endif %}{% if preflight_env.stdout | trim == '' %}  - RIVERMAX_LICENSE_PATH env var not set
          {% endif %}{% if 'MISSING' in preflight_adapter.stdout %}  - No Mellanox/ConnectX adapter found
          {% endif %}Fix: ansible-playbook playbooks/rivermax-setup.yml --limit {{ inventory_hostname }}
      when: >-
        not preflight_dll.stat.exists or
        not preflight_lic.stat.exists or
        preflight_env.stdout | trim == '' or
        'MISSING' in preflight_adapter.stdout

- name: Prepare nDisplay launch
  hosts: ue_content
  gather_facts: false

  tasks:
    - name: Validate nDisplay config is set
      ansible.builtin.assert:
        that:
          - ndisplay_config | length > 0
          - ndisplay_node is defined
        fail_msg: "ndisplay_config and ndisplay_node must be set. Populate ue_content.yml and hosts.yml."

    - name: Validate nDisplay config exists on disk
      ansible.windows.win_stat:
        path: "{{ ndisplay_config }}"
      register: config_check

    - name: Fail if nDisplay config not found
      ansible.builtin.fail:
        msg: "nDisplay config not found: {{ ndisplay_config }}"
      when: not config_check.stat.exists

    - name: Validate map exists on disk
      ansible.windows.win_stat:
        path: "{{ unreal_project | dirname }}/Content/{{ ndisplay_map | regex_replace('^/Game/', '') }}.umap"
      register: map_check
      when:
        - ndisplay_map is defined
        - ndisplay_map != 'None'

    - name: Fail if map not found
      ansible.builtin.fail:
        msg: "Map not found: {{ ndisplay_map }} (looked for {{ unreal_project | dirname }}/Content/{{ ndisplay_map | regex_replace('^/Game/', '') }}.umap)"
      when:
        - map_check is not skipped
        - not map_check.stat.exists

    - name: Stop any running UE instances
      ansible.windows.win_shell: |
        $procs = Get-Process -Name UnrealEditor -ErrorAction SilentlyContinue
        if ($procs) {
          $procs | Stop-Process -Force
          Start-Sleep -Seconds 3
          Write-Host "STOPPED $($procs.Count) process(es)"
        } else {
          Write-Host "NONE_RUNNING"
        }
      register: stop_result

    - name: Read node window settings from nDisplay config
      ansible.windows.win_shell: |
        $cfg = Get-Content "{{ ndisplay_config }}" -Raw | ConvertFrom-Json
        $node = $cfg.nDisplay.cluster.nodes."{{ ndisplay_node }}"
        $obj = @{
          winx = [int]$node.window.x
          winy = [int]$node.window.y
          resx = [int]$node.window.w
          resy = [int]$node.window.h
          fullscreen = [bool]$node.fullScreen
          headless = [bool]$node.renderHeadless
        }
        $obj | ConvertTo-Json -Compress
      register: ndisplay_node_cfg
      changed_when: false

    - name: Parse node window settings
      ansible.builtin.set_fact:
        ndisplay_window: "{{ ndisplay_node_cfg.stdout | from_json }}"

    - name: Build nDisplay launch arguments
      ansible.builtin.set_fact:
        ndisplay_args: >-
          "{{ unreal_project }}"
          -game
          {{ ndisplay_map | default('None') }}
          -dc_cluster
          -dc_cfg="{{ ndisplay_config }}"
          -dc_node={{ ndisplay_node }}
          -dc_dev_mono
          -ini:Engine:[/Script/Engine.Engine]:GameEngine=/Script/DisplayCluster.DisplayClusterGameEngine,[/Script/Engine.Engine]:GameViewportClientClassName=/Script/DisplayCluster.DisplayClusterViewportClient,[/Script/Engine.UserInterfaceSettings]:bAllowHighDPIInGameMode=True,[/Script/Engine.UserInterfaceSettings]:bAllowHighDpiWhenUnattended=True
          -ini:Game:[/Script/EngineSettings.GeneralProjectSettings]:bUseBorderlessWindow=True
          -ini:Input:[/Script/Engine.InputSettings]:DefaultPlayerInputClass=/Script/DisplayCluster.DisplayClusterPlayerInput
          -unattended
          -NoScreenMessages
          -nosplash
          -fixedseed
          -NoVerifyGC
          -noxrstereo
          -ini:Engine:[ConsoleVariables]:Rivermax.Output.EnableMultiSRD=1
          {% if ndisplay_window.fullscreen | bool %}-fullscreen{% else %}-windowed -forceres WinX={{ ndisplay_window.winx }} WinY={{ ndisplay_window.winy }} ResX={{ ndisplay_window.resx }} ResY={{ ndisplay_window.resy }}{% endif %}
          {% if ndisplay_window.headless | bool %}-RenderOffscreen{% endif %}
          {% if concert_server_ip is defined %}-messaging -CONCERTAUTOCONNECT -CONCERTSERVER="{{ concert_server_name }}" -CONCERTSESSION="{{ concert_session }}" -CONCERTDISPLAYNAME="{{ inventory_hostname }}" -UDPMESSAGING_TRANSPORT_UNICAST={{ ansible_host }}:0 -UDPMESSAGING_TRANSPORT_STATIC={{ concert_server_ip }}:{{ concert_server_port }} -ini:Engine:[/Script/UdpMessaging.UdpMessagingSettings]:MulticastEndpoint=0.0.0.0:0,[/Script/UdpMessaging.UdpMessagingSettings]:MulticastTimeToLive=0,[/Script/QuicMessaging.QuicMessagingSettings]:EnableTransport=False{% endif %}
          -RemoteControlIsHeadless
          -StageFriendlyName="{{ ndisplay_node }}"
          Log={{ ndisplay_node }}.log

    - name: Write nDisplay launch script
      ansible.windows.win_copy:
        content: |
          @echo off
          "{{ unreal_exe }}" {{ ndisplay_args }}
        dest: C:\ndisplay-launch.bat

    - name: Create nDisplay scheduled task
      community.windows.win_scheduled_task:
        name: nDisplayLaunch
        description: Launch UE in nDisplay mode
        actions:
          - path: C:\ndisplay-launch.bat
        triggers: []
        username: "{{ ansible_user }}"
        password: "{{ ansible_password }}"
        logon_type: interactive_token
        run_level: highest
        state: present
        enabled: true

- name: Launch nDisplay cluster
  hosts: ue_content
  gather_facts: false

  tasks:
    - name: Start nDisplay on all nodes
      ansible.windows.win_shell: |
        Start-ScheduledTask -TaskName "nDisplayLaunch"
        Write-Host "LAUNCHED"

    - name: Wait for UE process to appear
      ansible.windows.win_shell: |
        $timeout = 30
        $elapsed = 0
        while ($elapsed -lt $timeout) {
          $proc = Get-Process -Name UnrealEditor -ErrorAction SilentlyContinue
          if ($proc) {
            Write-Host "RUNNING (PID: $($proc.Id))"
            exit 0
          }
          Start-Sleep -Seconds 2
          $elapsed += 2
        }
        throw "UnrealEditor did not start within ${timeout}s"
      register: launch_result

    - name: Show launch status
      ansible.builtin.debug:
        msg: "{{ inventory_hostname }} ({{ ndisplay_node }}): {{ launch_result.stdout | trim }}"
